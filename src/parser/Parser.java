package parser;

import ast.*;
import java.math.BigInteger;
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "calculator.grammar".
 */
public class Parser extends beaver.Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(Parser.class);

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] $goal = Program
			new Action() {	// [1] Exp = Exp.e1 PLUS Exp.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new Plus(e1, e2);
				}
			},
			new Action() {	// [2] Exp = Exp.e1 MINUS Exp.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new Minus(e1, e2);
				}
			},
			new Action() {	// [3] Exp = Exp.e1 TIMES Exp.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new Times(e1, e2);
				}
			},
			new Action() {	// [4] Exp = Exp.e1 DIVIDE Exp.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new Divide(e1, e2);
				}
			},
			new Action() {	// [5] Exp = Exp.e1 MOD Exp.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new Mod(e1, e2);
				}
			},
			new Action() {	// [6] Exp = Exp.e1 EXP Exp.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new Expn(e1, e2);
				}
			},
			new Action() {	// [7] Exp = INT_LIT.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 1];
					final Integer i = (Integer) _symbol_i.value;
					 return new IntLit(BigInteger.valueOf(i));
				}
			},
			new Action() {	// [8] Exp = LPAREN Exp.e RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Exp e = (Exp) _symbol_e.value;
					 return e;
				}
			},
			new Action() {	// [9] Exp = ID.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					 return new Identifier(i);
				}
			},
			new Action() {	// [10] Assign = ID.i EQUALS Exp.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Exp e = (Exp) _symbol_e.value;
					 return new Assign(i, e);
				}
			},
			new Action() {	// [11] ForLoop = FORL Exp.e SEMI Program.p
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Exp e = (Exp) _symbol_e.value;
					final Symbol _symbol_p = _symbols[offset + 4];
					final Program p = (Program) _symbol_p.value;
					 return new For(e, p);
				}
			},
			new Action() {	// [12] Print = PRINT ID.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					 return new Print(i);
				}
			},
			new Action() {	// [13] Program = Program.p Exp.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p = _symbols[offset + 1];
					final Program p = (Program) _symbol_p.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final Exp e = (Exp) _symbol_e.value;
					 p.add(e); return p;
				}
			},
			new Action() {	// [14] Program = Program.p Assign.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p = _symbols[offset + 1];
					final Program p = (Program) _symbol_p.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final Assign a = (Assign) _symbol_a.value;
					 p.add(a); return p;
				}
			},
			new Action() {	// [15] Program = Program.p ForLoop.f SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p = _symbols[offset + 1];
					final Program p = (Program) _symbol_p.value;
					final Symbol _symbol_f = _symbols[offset + 2];
					final For f = (For) _symbol_f.value;
					 p.add(f); return p;
				}
			},
			new Action() {	// [16] Program = Program.p Print.pr SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p = _symbols[offset + 1];
					final Program p = (Program) _symbol_p.value;
					final Symbol _symbol_pr = _symbols[offset + 2];
					final Print pr = (Print) _symbol_pr.value;
					 p.add(pr); return p;
				}
			},
			new Action() {	// [17] Program = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Program();
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
